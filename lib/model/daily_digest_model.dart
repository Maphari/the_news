/// Represents a daily news digest generated by AI
class DailyDigest {
  final String digestId;
  final String userId;
  final DateTime generatedAt;
  final String title;
  final String summary;
  final List<DigestItem> items;
  final List<String> sourceArticleIds;
  final DigestPersonalization personalization;
  final String? audioUrl;
  final int estimatedReadingMinutes;
  final bool isRead;
  final DateTime? readAt;

  const DailyDigest({
    required this.digestId,
    required this.userId,
    required this.generatedAt,
    required this.title,
    required this.summary,
    required this.items,
    required this.sourceArticleIds,
    required this.personalization,
    this.audioUrl,
    required this.estimatedReadingMinutes,
    this.isRead = false,
    this.readAt,
  });

  DailyDigest copyWith({
    bool? isRead,
    DateTime? readAt,
  }) {
    return DailyDigest(
      digestId: digestId,
      userId: userId,
      generatedAt: generatedAt,
      title: title,
      summary: summary,
      items: items,
      sourceArticleIds: sourceArticleIds,
      personalization: personalization,
      audioUrl: audioUrl,
      estimatedReadingMinutes: estimatedReadingMinutes,
      isRead: isRead ?? this.isRead,
      readAt: readAt ?? this.readAt,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'digestId': digestId,
      'userId': userId,
      'generatedAt': generatedAt.toIso8601String(),
      'title': title,
      'summary': summary,
      'items': items.map((item) => item.toJson()).toList(),
      'sourceArticleIds': sourceArticleIds,
      'personalization': personalization.toJson(),
      'audioUrl': audioUrl,
      'estimatedReadingMinutes': estimatedReadingMinutes,
      'isRead': isRead,
      'readAt': readAt?.toIso8601String(),
    };
  }

  factory DailyDigest.fromJson(Map<String, dynamic> json) {
    return DailyDigest(
      digestId: json['digestId'] as String,
      userId: json['userId'] as String,
      generatedAt: DateTime.parse(json['generatedAt'] as String),
      title: json['title'] as String,
      summary: json['summary'] as String,
      items: (json['items'] as List)
          .map((item) => DigestItem.fromJson(item as Map<String, dynamic>))
          .toList(),
      sourceArticleIds: (json['sourceArticleIds'] as List).cast<String>(),
      personalization: DigestPersonalization.fromJson(
        json['personalization'] as Map<String, dynamic>,
      ),
      audioUrl: json['audioUrl'] as String?,
      estimatedReadingMinutes: json['estimatedReadingMinutes'] as int,
      isRead: json['isRead'] as bool? ?? false,
      readAt: json['readAt'] != null
          ? DateTime.parse(json['readAt'] as String)
          : null,
    );
  }
}

/// Individual item in a daily digest
class DigestItem {
  final String itemId;
  final String headline;
  final String summary;
  final String category;
  final List<String> keyPoints;
  final String whyItMatters;
  final List<String> relatedArticleIds;
  final DigestItemType type;
  final int priority;

  const DigestItem({
    required this.itemId,
    required this.headline,
    required this.summary,
    required this.category,
    required this.keyPoints,
    required this.whyItMatters,
    required this.relatedArticleIds,
    required this.type,
    required this.priority,
  });

  Map<String, dynamic> toJson() {
    return {
      'itemId': itemId,
      'headline': headline,
      'summary': summary,
      'category': category,
      'keyPoints': keyPoints,
      'whyItMatters': whyItMatters,
      'relatedArticleIds': relatedArticleIds,
      'type': type.name,
      'priority': priority,
    };
  }

  factory DigestItem.fromJson(Map<String, dynamic> json) {
    return DigestItem(
      itemId: json['itemId'] as String,
      headline: json['headline'] as String,
      summary: json['summary'] as String,
      category: json['category'] as String,
      keyPoints: (json['keyPoints'] as List).cast<String>(),
      whyItMatters: json['whyItMatters'] as String,
      relatedArticleIds: (json['relatedArticleIds'] as List).cast<String>(),
      type: DigestItemType.values.firstWhere(
        (e) => e.name == json['type'],
        orElse: () => DigestItemType.news,
      ),
      priority: json['priority'] as int,
    );
  }
}

/// Type of digest item
enum DigestItemType {
  news('Breaking News', 'Latest news story'),
  trending('Trending', 'Popular story'),
  analysis('Analysis', 'In-depth analysis'),
  opinion('Opinion', 'Expert opinion'),
  local('Local', 'Local news'),
  followed('Following', 'From sources you follow');

  final String label;
  final String description;

  const DigestItemType(this.label, this.description);
}

/// Personalization data for digest
class DigestPersonalization {
  final List<String> followedSources;
  final List<String> preferredCategories;
  final Map<String, double> categoryWeights;
  final String userLocation;
  final String readingLevel; // 'quick', 'standard', 'detailed'
  final bool includeOpinions;
  final bool includeInternational;

  const DigestPersonalization({
    required this.followedSources,
    required this.preferredCategories,
    required this.categoryWeights,
    required this.userLocation,
    this.readingLevel = 'standard',
    this.includeOpinions = true,
    this.includeInternational = true,
  });

  Map<String, dynamic> toJson() {
    return {
      'followedSources': followedSources,
      'preferredCategories': preferredCategories,
      'categoryWeights': categoryWeights,
      'userLocation': userLocation,
      'readingLevel': readingLevel,
      'includeOpinions': includeOpinions,
      'includeInternational': includeInternational,
    };
  }

  factory DigestPersonalization.fromJson(Map<String, dynamic> json) {
    return DigestPersonalization(
      followedSources: (json['followedSources'] as List).cast<String>(),
      preferredCategories: (json['preferredCategories'] as List).cast<String>(),
      categoryWeights: (json['categoryWeights'] as Map).map(
        (key, value) => MapEntry(key as String, (value as num).toDouble()),
      ),
      userLocation: json['userLocation'] as String,
      readingLevel: json['readingLevel'] as String? ?? 'standard',
      includeOpinions: json['includeOpinions'] as bool? ?? true,
      includeInternational: json['includeInternational'] as bool? ?? true,
    );
  }
}

/// Settings for digest generation
class DigestSettings {
  final DigestFrequency frequency;
  final TimeOfDay preferredTime;
  final int maxItems;
  final bool enableNotifications;
  final bool generateAudio;
  final List<String> excludedCategories;
  final DigestTone tone;

  // Advanced scheduling options
  final List<int> scheduledDays; // 1=Monday, 7=Sunday (empty = all days)
  final TimeOfDay? secondaryTime; // For twice daily option
  final bool autoGenerateOnWake; // Generate when app opens if not generated today
  final bool skipWeekends; // Skip Sat & Sun
  final int quietHoursStart; // Hour to avoid notifications (e.g., 22 for 10 PM)
  final int quietHoursEnd; // Hour to resume notifications (e.g., 7 for 7 AM)
  final bool adaptiveScheduling; // Adjust time based on user's reading patterns

  const DigestSettings({
    this.frequency = DigestFrequency.daily,
    this.preferredTime = const TimeOfDay(hour: 7, minute: 0),
    this.maxItems = 5,
    this.enableNotifications = true,
    this.generateAudio = false,
    this.excludedCategories = const [],
    this.tone = DigestTone.balanced,
    this.scheduledDays = const [],
    this.secondaryTime,
    this.autoGenerateOnWake = true,
    this.skipWeekends = false,
    this.quietHoursStart = 22,
    this.quietHoursEnd = 7,
    this.adaptiveScheduling = false,
  });

  Map<String, dynamic> toJson() {
    return {
      'frequency': frequency.name,
      'preferredTimeHour': preferredTime.hour,
      'preferredTimeMinute': preferredTime.minute,
      'maxItems': maxItems,
      'enableNotifications': enableNotifications,
      'generateAudio': generateAudio,
      'excludedCategories': excludedCategories,
      'tone': tone.name,
      'scheduledDays': scheduledDays,
      'secondaryTimeHour': secondaryTime?.hour,
      'secondaryTimeMinute': secondaryTime?.minute,
      'autoGenerateOnWake': autoGenerateOnWake,
      'skipWeekends': skipWeekends,
      'quietHoursStart': quietHoursStart,
      'quietHoursEnd': quietHoursEnd,
      'adaptiveScheduling': adaptiveScheduling,
    };
  }

  factory DigestSettings.fromJson(Map<String, dynamic> json) {
    final secondaryHour = json['secondaryTimeHour'] as int?;
    final secondaryMinute = json['secondaryTimeMinute'] as int?;

    return DigestSettings(
      frequency: DigestFrequency.values.firstWhere(
        (e) => e.name == json['frequency'],
        orElse: () => DigestFrequency.daily,
      ),
      preferredTime: TimeOfDay(
        hour: json['preferredTimeHour'] as int? ?? 7,
        minute: json['preferredTimeMinute'] as int? ?? 0,
      ),
      maxItems: json['maxItems'] as int? ?? 5,
      enableNotifications: json['enableNotifications'] as bool? ?? true,
      generateAudio: json['generateAudio'] as bool? ?? false,
      excludedCategories: (json['excludedCategories'] as List?)?.cast<String>() ?? [],
      tone: DigestTone.values.firstWhere(
        (e) => e.name == json['tone'],
        orElse: () => DigestTone.balanced,
      ),
      scheduledDays: (json['scheduledDays'] as List?)?.cast<int>() ?? [],
      secondaryTime: secondaryHour != null && secondaryMinute != null
          ? TimeOfDay(hour: secondaryHour, minute: secondaryMinute)
          : null,
      autoGenerateOnWake: json['autoGenerateOnWake'] as bool? ?? true,
      skipWeekends: json['skipWeekends'] as bool? ?? false,
      quietHoursStart: json['quietHoursStart'] as int? ?? 22,
      quietHoursEnd: json['quietHoursEnd'] as int? ?? 7,
      adaptiveScheduling: json['adaptiveScheduling'] as bool? ?? false,
    );
  }

  DigestSettings copyWith({
    DigestFrequency? frequency,
    TimeOfDay? preferredTime,
    int? maxItems,
    bool? enableNotifications,
    bool? generateAudio,
    List<String>? excludedCategories,
    DigestTone? tone,
    List<int>? scheduledDays,
    TimeOfDay? secondaryTime,
    bool? autoGenerateOnWake,
    bool? skipWeekends,
    int? quietHoursStart,
    int? quietHoursEnd,
    bool? adaptiveScheduling,
  }) {
    return DigestSettings(
      frequency: frequency ?? this.frequency,
      preferredTime: preferredTime ?? this.preferredTime,
      maxItems: maxItems ?? this.maxItems,
      enableNotifications: enableNotifications ?? this.enableNotifications,
      generateAudio: generateAudio ?? this.generateAudio,
      excludedCategories: excludedCategories ?? this.excludedCategories,
      tone: tone ?? this.tone,
      scheduledDays: scheduledDays ?? this.scheduledDays,
      secondaryTime: secondaryTime ?? this.secondaryTime,
      autoGenerateOnWake: autoGenerateOnWake ?? this.autoGenerateOnWake,
      skipWeekends: skipWeekends ?? this.skipWeekends,
      quietHoursStart: quietHoursStart ?? this.quietHoursStart,
      quietHoursEnd: quietHoursEnd ?? this.quietHoursEnd,
      adaptiveScheduling: adaptiveScheduling ?? this.adaptiveScheduling,
    );
  }
}

/// Frequency of digest generation
enum DigestFrequency {
  twiceDaily('Twice Daily', 'Morning and evening'),
  daily('Daily', 'Once per day'),
  weekdays('Weekdays', 'Monday to Friday'),
  weekly('Weekly', 'Once per week');

  final String label;
  final String description;

  const DigestFrequency(this.label, this.description);
}

/// Tone for digest content
enum DigestTone {
  formal('Formal', 'Professional and serious'),
  balanced('Balanced', 'Mix of formal and casual'),
  casual('Casual', 'Conversational and friendly'),
  concise('Concise', 'Brief and to the point');

  final String label;
  final String description;

  const DigestTone(this.label, this.description);
}

/// Time of day for scheduling
class TimeOfDay {
  final int hour; // 0-23
  final int minute; // 0-59

  const TimeOfDay({
    required this.hour,
    required this.minute,
  });

  String toFormattedString() {
    final period = hour >= 12 ? 'PM' : 'AM';
    final displayHour = hour > 12 ? hour - 12 : (hour == 0 ? 12 : hour);
    final displayMinute = minute.toString().padLeft(2, '0');
    return '$displayHour:$displayMinute $period';
  }

  @override
  String toString() => toFormattedString();
}
